== DML statements

Next to the support for `SELECT` statements, {projectname} also has support for

* `UPDATE`
* `DELETE`
* `INSERT ... SELECT`

The construction of query builders for such statements works through the link:{core_doc}/persistence/CriteriaBuilderFactory.html[`CriteriaBuilderFactory`] API.

=== DELETE statement

The `DELETE` statement deletes entities that satisfy the `WHERE` clause of the statement.
A delete builder can be created via link:{core_doc}/persistence/CriteriaBuilderFactory.html#delete(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)[`CriteriaBuilderFactory.delete()`].

[source,java]
----
DeleteCriteriaBuilder<Cat> cb = cbf.delete(em, Cat.class, "cat")
    .where("cat.name").isNull();
----

[source,sql]
----
DELETE FROM Cat cat
WHERE cat.name IS NULL
----

You can immediately execute the query by calling link:{core_doc}/persistence/Executable.html#executeUpdate()[`executeUpdate()`]
or create a JPA `Query` by calling link:{core_doc}/persistence/Executable.html#getQuery()[`getQuery()`].

NOTE: Since a `DELETE` statement can't have joins, implicit joins generated by deep path expressions are disallowed. Use an `EXISTS` subquery if you need to join relations.

PRO-TIP: If your DBMS supports it, cascading deletes will be implemented as CTEs when deleting entities through this API.

=== UPDATE statement

The `UPDATE` statement updates attributes as specified in the `SET` clause on entities that satisfy the `WHERE` clause of the statement.
An update builder can be created via link:{core_doc}/persistence/CriteriaBuilderFactory.html#update(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)[`CriteriaBuilderFactory.update()`].

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .set("name")
        .from(Person.class, "p")
        .where("p").eqExpression("cat.owner")
        .select("CONCAT(p.name, '''s cat')")
    .end()
    .where("name").isNull();
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = (
    SELECT CONCAT(p.name, '''s cat')
    FROM Person p
    WHERE p = cat.owner
)
WHERE cat.name IS NULL
----

There are multiple `set()` variants to be able to cover all possible expressions.

link:{core_doc}/persistence/BaseUpdateCriteriaBuilder.html#set(java.lang.String,%20java.lang.Object)[`set(String, Object)`]::
Set the attribute to the given value. This will create an implicit parameter expression and set the value.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .set("name", "Billy2")
    .where("name").eq("Billy");
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = :param_1
WHERE cat.name = :param_2
----

link:{core_doc}/persistence/BaseUpdateCriteriaBuilder.html#set(java.lang.String)[`set(String)`]::
Starts a subquery builder for the attribute.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .set("name")
        .from(Person.class, "p")
        .where("p").eqExpression("cat.owner")
        .select("CONCAT(p.name, '''s cat')")
    .end()
    .where("cat.name").eq("Billy");
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = (
    SELECT CONCAT(p.name, '''s cat')
    FROM Person p
    WHERE p = cat.owner
)
WHERE cat.name = :param_1
----

link:{core_doc}/persistence/BaseUpdateCriteriaBuilder.html#setExpression(java.lang.String,%20java.lang.String)[`setExpression(String, String)`]::
Uses the given expression for the assignment to the attribute.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .setExpression("name", "UPPER(name)")
    .where("cat.name").eq("Billy");
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = UPPER(cat.name)
WHERE cat.name = :param_1
----

link:{core_doc}/persistence/BaseUpdateCriteriaBuilder.html#setSubqueries(java.lang.String,%20java.lang.String)[`setSubqueries(String, String)`]::
Starts a subquery builder capable of handling multiple subqueries and assigns the given `expression` to the attribute.
Subqueries are started with `with(String subqueryAlias)` and aliases occurring in the expression will be replaced by the respective subquery expressions.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .setSubqueries("name", "CONCAT(ownerSubquery, ' the cat'")
        .with("ownerSubquery")
            .from(Person.class, "p")
            .where("p").eqExpression("cat.owner")
            .select("p.name")
        .end()
    .end()
    .where("cat.name").eq("Billy");
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = CONCAT((
    SELECT p.name
    FROM Person p
    WHERE p = cat.owner
), '''s cat')
WHERE cat.name = :param_1
----

WARNING: Currently there is no possibility to do a `VERSIONED` update like you could do with e.g. Hibernate.

You can immediately execute the query by calling link:{core_doc}/persistence/Executable.html#executeUpdate()[`executeUpdate()`]
or create a JPA `Query` by calling link:{core_doc}/persistence/Executable.html#getQuery()[`getQuery()`].

NOTE: Since an `UPDATE` statement can't have joins, implicit joins generated by deep path expressions are disallowed. Use an `EXISTS` subquery if you need to join relations or a scalar subquery if you need joins for setting attributes.

// TODO: test update that involves multiple tables => Could we use CTEs here too?

=== INSERT-SELECT statement
// With Hibernate you can also do insert-into-select

==== CTE support

If the underlying DBMS supports the use of CTEs on _modification_ statements, you can make use of those by defining them via link:{core_doc}/persistence/CTEBuilder.html#with(java.lang.Class)[`with()`].
For further information on this, check out the <<ctes,CTE chapter>>.

// TODO: When fixing #337 we could actually fallback to inlining for non-recursive CTEs on DBMS that don't support CTEs

=== RETURNING clause support

// Most DBMS only support returning the id, some even only support the last id, which is why the API is that way
// Show examples of returning deleted/updated/inserted entites
// Mention you can use DML in CTEs on PostgreSQL and DB2, but refer to CTE chapter