== General

CTEs provide a way to introduce statements into a larger query that can be reused. CTEs are like temporary tables that are created for the scope of the query and then deleted.
A CTE can normally be SELECT but also depending on the native database support an INSERT, UPDATE and DELETE.

WARNING: This feature is currently only supported with Hibernate!

First the structure of the view has to be defined in a similar manner as an entity is defined. Don't forget to also add it to your persistence.xml so that the JPA provider can discover it.

[source,java]
----
@com.blazebit.persistence.CTE
@javax.persistence.Entity
public class MyCte {

    private Long id;

    @javax.persistence.Id
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
}
----

The difference to a normal entity is that the `CTE` annotation is applied.
To define a CTE in a query, the `with(Class<?>)` method has to be invoked which starts a builder that finally has to be closed with `end`.

All attributes of a CTE must be bound to expressions with `bind` like in the following.

[source,java]
----
CriteriaBuilder<MyCte> cb = cbf.create(em, MyCte.class)
    .with(MyCte.class)
        .from(Cat.class, "cat")
        .bind("id").select("cat.id")
    .end();
----

As you can see from the example, the API tries to look as much as possible like the CTEs defined in the SQL-99 standard.
The query returned by `cb.getQueryString()` is a _logical_ representation of the whole query in a syntax that might be used on day by JPA providers to support this feature natively.

[source,sql]
----
WITH MyCte(id) AS(
SELECT cat.id FROM Cat cat
)
SELECT myCte FROM MyCte myCte
----

=== Implementation notes

Currently CTE support is only implemented for Hibernate because of the deep integration that is needed.
The integration with the persistence provider happens in the implementation of `com.blazebit.persistence.spi.ExtendedQuerySupport`
which tries to focus on the minimal necessary methods needed for the integration to work.

In case of Hibernate a CTE entity class is treated as if `org.hibernate.annotations.Subselect` was annotated.
During query generation, the subquery generated by Hibernate will be replaced by the CTE name.

The current implementation extracts the SQL from various template JPQL queries that are created behind the scenes.
After applying different transformations on the SQL and merging it together to a single query, that SQL replaces the original SQL of a special JPQL query object.
When executing the final JPQL query, the transformed SQL gets executed.

Every CTE will result in a separate JPQL query behind the scenes from which the SQL is extracted.
The SQL from the main query together with the SQLs from the CTEs are put together together to form the full SQL query.
That SQL will be the query exectued by another newly created and separately cached JPQL query.

NOTE: In order to support the `org.hibernate.FetchMode.SUBSELECT` this library ships with custom implementations of `org.hibernate.persister.collection.CollectionPersister`.
Custom persister implementations should be made aware of CTEs in a similar fashion to be able to make use of the fetch mode.

=== RDBMS compatibility

Currently there is no emulation implemented for databases that do not support CTEs natively.
The features are well tested with *PostgreSQL* and *DB2*. Many of the basic features work with *H2*.

The implementations for *Oracle* and *Microsoft SQL Server* are neither tested nor complete, so don't expect the features to work on these databases.

NOTE: DB2 does not support JOINs in the recursive part of a CTE: https://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/com.ibm.db2z10.doc.codes/src/tpc/n345.dita

TODO: Make a table that shows which DB supports what

=== Normal CTEs

CTEs not only provide a way to extract subqueries or use subqueries in the FROM clause,
but also to implement recursive queries.

A recursive CTE is normally composed of two parts, a base query(non-recursive query) and a recursive query connected with the *SET* operator *UNION* or *UNION ALL*.
The recursive part is allowed to refer to the CTE itself.

A recursive CTE is normally evaluated in iterations

1. The base query is evaluated and the result put into a temporary work table
2. The recursive query operates on the work table data and replaces it with the newly produced data
3. When the recursive query didn't produce data, the recursion and thus the query is finished

The following illustrates how the ancestor hierarchy of an entity can be retrieved.

[source,java]
.CTE structure definition
----
@com.blazebit.persistence.CTE
@javax.persistence.Entity
public class CatCte {

    private Long id;
    private Cat ancestor;

    @javax.persistence.Id
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    @ManyToOne
    public Cat getAncestor() { return ancestor; }
    public void setAncestor(Cat ancestor) { this.ancestor = ancestor; }
}
----

[source,java]
.Recursive query
----
CriteriaBuilder<CatCte> cb = cbf.create(em, CatCte.class)
    .withRecursive(CatCte.class)
        .from(Cat.class, "cat")
        .bind("id").select("cat.id")
        .bind("ancestor").select("cat.ancestor")
        .where("id").eq(someCatId)
    .unionAll()
        .from(Cat.class, "cat")
        .from(CatCte.class, "parentCat")
        .bind("id").select("cat.id")
        .bind("ancestor").select("cat.ancestor")
        .where("id").eqExpression("parentCat.ancestor.id")
    .end();
----

[source,sql]
.Logical representation
----
WITH RECURSIVE CatCte(id, ancestor) AS(
SELECT cat.id, cat.ancestor FROM Cat cat WHERE cat.id = :someCatId
UNION ALL
SELECT cat.id, cat.ancestor FROM Cat cat, CatCte parentCat WHERE cat.id = parentCat.ancestor.id
)
SELECT catCte FROM CatCte catCte
----

This will return all the ancestors of the Cat with an id equal to *someCatId*.

TODO: Give some examples of normal and recursive CTEs

=== Updatable CTEs

TODO: Give examples of updatable CTEs and describe the OLD and NEW views on entity data