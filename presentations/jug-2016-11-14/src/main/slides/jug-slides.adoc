= Blaze-Persistence, Tomorrow's JPA, today
Christian Beikov, Moritz Becker
:icons: font
:split:
:navigation:
:blank: pass:[ +]
:markstart: pass:[<span class="mark">]
:markend: pass:[</span>]

== About us

image::vendor.png[float="right"]

icon:twitter[] https://twitter.com/Blazebit[@Blazebit] +
icon:github[] https://github.com/Blazebit

Blazebit Gesbr. is a working group doing commercial software and OSS under APL 2.0

[%step]
--
image::christian_head.png[float="right"]

{blank}

* Christian Beikov, Blaze-Persistence lead

--

[%step]
--
image::moritz_head.png[float="right"]

{blank}

* Moritz Becker, Blaze-Persistence comitter

--

[%step]
--
image::bernd_head.png[float="right"]

{blank}

* Bernd Artm+++&uuml;+++ller, Designer

--

== What is Blaze-Persistence

* Library that builds on top of JPA with deep integration
* Fluent builder API that is easy to use
* Rich pagination support integrated
* Entity-Views as painless DTOs
* Advanced SQL support on top of JPA model

== Problems with ORM/JPA

// List the problems that people have with ORMs and show the bad decisions that have to be made because of that.

* Think JPA 2.1 Entity-Graphs are too verbose?

[source,java]
----
@Entity
@NamedEntityGraph(
    name = "Cat.catWithKittensParents",
    attributeNodes = @NamedAttributeNode(value = "kittens", subgraph = "kittens"),
    subgraphs = @NamedSubgraph(name = "kittens", attributeNodes = {
        @NamedAttributeNode("father"), @NamedAttributeNode("mother")
    })
)
public class Cat {
    @Id @GeneratedValue
    private int id;
    private String name;
    @OneToMany
    private Set<Cat> kittens;
    @ManyToOne(fetch = Fetch.LAZY)
    private Cat mother;
    @ManyToOne(fetch = Fetch.LAZY)
    private Cat father;
}
----

<<<

* Fetch-problems with loading the _"whole"_ database or `LazyInitializationExceptions`?

[source,java,subs="verbatim,attributes"]
----
public class Cat {
    @Id @GeneratedValue
    private int id;
    private String name;
    @OneToMany(fetch = Fetch.{markstart}EAGER{markend})
    private Set<Cat> kittens;
    @ManyToOne(fetch = Fetch.{markstart}EAGER{markend})
    private Cat mother;
    @ManyToOne(fetch = Fetch.{markstart}EAGER{markend})
    private Cat father;
}
----

[source,java]
----
entityManager.find(Cat.class, catId);
----

Leading to loading all relations...

<<<

* Fetch-problems with loading the _"whole"_ database or `LazyInitializationExceptions`?

[source,java,subs="verbatim,attributes"]
----
public class Cat {
    @Id @GeneratedValue
    private int id;
    private String name;
    @OneToMany(fetch = Fetch.{markstart}LAZY{markend})
    private Set<Cat> kittens;
    @ManyToOne(fetch = Fetch.{markstart}LAZY{markend})
    private Cat mother;
    @ManyToOne(fetch = Fetch.{markstart}LAZY{markend})
    private Cat father;
}
----

[source,java]
----
Cat c = entityManager.find(Cat.class, catId);
c.getFather().getName();
----

Leading to a `LazyInitializationExceptions` on invocation of `getName()`

<<<

* JPA constructor expressions for DTOs too inflexible?

[source,sql]
----
SELECT new com.company.somepackage.dto.MyCatDTO(
    c.name, kitten.name, father.name, mother.name
) FROM Cat c
LEFT JOIN FETCH c.kittens kitten
LEFT JOIN FETCH kitten.father father
LEFT JOIN FETCH kitten.mother mother
----

Results in flat objects, no hierarchies possible except you do something like that...

[source,java]
----
entityManager.createQuery(query, MyCatDTO.class)
    .getResultList()
    .stream()
    .collect(Collectors.groupingBy(MyCatDTO::getName, dto -> new MySubCatDTO(dto))
    .entrySet()
    .stream()
    .map(entry -> new MyMainCatDTO(entry.getKey(), entry.getValue()))
    .collect(Collectors.toList());
----

<<<

* Missing support for that one little SQL feature that you really need?

<<<

* Having some longstanding problems with the JPA provider that don't seem to get fixed?

<<<

* Feel like you can't reuse parts of queries and have to duplicate code?

<<<

* Think JPA 2.1 Entity-Graphs are too verbose?
* Fetch-problems with loading the _"whole"_ database or `LazyInitializationExceptions`?
* JPA constructor expressions for DTOs too inflexible?
* Missing support for that one little SQL feature that you really need?
* Having some longstanding problems with the JPA provider that don't seem to get fixed?
* Feel like you can't reuse parts of queries and have to duplicate code?

[position=center]
*Blaze-Persistence got you covered!*

Let's see how Blaze-Persistence helps you out with these problems!

== Blaze-Persistence features/use cases

List the features/use cases for which Blaze-Persistence can be used.
For every feature, give live examples + comparison

== Entity-views

Entity-views are the ORM equivalent of database views.

You can use them to optimize entity fetching.
Most of the time you do not need full entities.
Querying only the parts you need reduces data transfer.

Some example use cases:

* Display data in UI

* Fetch data to be returned in REST resources

* (Soon: partial updates)

[%step]
Entity-views showcase

== Pagination

Blaze-persistence supports two types of pagination:

* Offset pagination

* Keyset pagination

Keyset pagination is preferable to offset pagination since it allows consistent pagination of data while elements are inserted.

[NOTE]
Pagination can also be combined with entity-views!

[%step]
Pagination showcase

== Common Table Expressions

Common Table Expressions (CTEs) are disposable tables created in memory only for the current statement.

Use cases:

* If you need to refer to a subquery multiple times, it can be convenient to extract it into a CTE - this way the subquery is evaluated only once

* With CTEs it is possible to query recursive structures efficiently

[NOTE]
CTEs can also be combined with pagination and entity-views!

[%step]
CTE showcase

== Integrations

Hibernate is the only JPA provider that has deep integration right now:

* Fixes/workarounds for known Hibernate bugs + limitations

* Support for advanced SQL features like CTEs

We provide integrations for CDI and Spring allowing the auto-discovery of entity views.

== Getting started with CDI

[source, java]
----
@ApplicationScoped
public class BlazePersistenceProducer {

    @Inject
    private EntityManagerFactory emf;

    @Inject
    private EntityViewConfiguration entityViewConfiguration;

    @Produces
    @ApplicationScoped
    public CriteriaBuilderFactory createCriteriaBuilderFactory() {
        CriteriaBuilderConfiguration config = Criteria.getDefault();
        return config.createCriteriaBuilderFactory(emf);
    }

    @Produces
    @ApplicationScoped
    public EntityViewManager createEntityViewManager(CriteriaBuilderFactory criteriaBuilderFactory) {
        return entityViewConfiguration.createEntityViewManager(criteriaBuilderFactory, emf);
    }
}
----

== Getting started with Spring

[source,java]
----
@Configuration
public class BlazePersistenceConfiguration {

    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;

    @Bean
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    @Lazy(false)
    public CriteriaBuilderFactory createCriteriaBuilderFactory() {
        CriteriaBuilderConfiguration config = Criteria.getDefault();
        // do some configuration
        return config.createCriteriaBuilderFactory(entityManagerFactory);
    }

    @Bean
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    @Lazy(false)
    public EntityViewManager createEntityViewManager(CriteriaBuilderFactory cbf, EntityViewConfiguration entityViewConfiguration) {
        return entityViewConfiguration.createEntityViewManager(cbf, entityManagerFactory);
    }
}
----

== Roadmap

List new features that are about to come

* Updateable entity views

== Contributing

We are happy about any contribution, please fork us and join us on Slack.

== Q & A

Got questions?
